#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable

#include "random.glsl"
#include "ray_common.glsl"

layout(binding = 0, set = 0, rgba32f) uniform image2D image;
layout(binding = 0, set = 1) uniform accelerationStructureEXT topLevelAS;
layout(binding = 0, set = 2) uniform CameraProperties {
    mat4 proj;
    mat4 view;
    mat4 inverse_view;
    mat4 inverse_proj;
} cam;
layout(location = 0) rayPayloadEXT RayPayload payload;

layout(push_constant) uniform Push {
    vec3 clear_color;
    uint frame_number;
} push;

const int MAX_DEPTH = 5;

void main() {
    uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, push.frame_number);
    float r1 = rnd(seed);
    float r2 = rnd(seed);
    vec2 subpixel_jitter = push.frame_number == 0 ? vec2(0.5, 0.5) : vec2(r1, r2);

    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + subpixel_jitter;
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec4 origin = cam.inverse_view * vec4(0, 0, 0, 1);
    vec4 target = cam.inverse_proj * vec4(d.xy, 1, 1);
    vec4 direction = cam.inverse_view * vec4(normalize(target.xyz), 0);

    vec3 rayOrigin = origin.xyz;
    vec3 rayDirection = direction.xyz;

    payload.seed = seed;
    payload.color = vec3(0.0);
    payload.throughput = vec3(1.0);
    payload.firstBounce = true;
    payload.isSpecular = false;

    const float RR_START_DEPTH = 3;

    for (int depth = 0; depth < MAX_DEPTH; depth++) {
        if (depth >= RR_START_DEPTH) {
            float maxThroughput = max(payload.throughput.r, max(payload.throughput.g, payload.throughput.b));
            float p = min(max(maxThroughput, 0.05), 0.95);

            if (rnd(seed) > p) {
                break;
            }

            payload.throughput /= p;
        }

        traceRayEXT(
            topLevelAS,
            gl_RayFlagsOpaqueEXT,
            0xFF,
            0,
            0,
            0,
            rayOrigin,
            0.001,
            rayDirection,
            10000.0,
            0
        );

        if (!payload.hit) {
            payload.color += payload.throughput * push.clear_color;
            break;
        }

        rayOrigin = payload.hitPosition;
        rayDirection = payload.nextDirection;

        // Check for invalid throughput (can happen with some BRDFs)
        if (any(isnan(payload.throughput)) || any(isinf(payload.throughput)) ||
                all(lessThan(payload.throughput, vec3(0.001)))) {
            break; // Path is terminated if throughput becomes invalid or too small
        }
    }

    // Sanitize final color
    vec3 finalColor = payload.color;
    if (any(isnan(finalColor)) || any(isinf(finalColor))) {
        finalColor = vec3(0.0); // Default to black for invalid colors
    }

    // Clamp to reasonable values to avoid bright spots
    // finalColor = clamp(finalColor, vec3(0.0), vec3(10.0));
    finalColor = pow(finalColor, vec3(1.0 / 2.2));

    if (push.frame_number == 0) {
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(payload.color, 1.f));
    } else {
        float a = 1.0 / float(push.frame_number + 1);
        vec3 old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).rgb;
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color, payload.color, a), 1.f));
    }
}
