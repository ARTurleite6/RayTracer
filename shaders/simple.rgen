#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable

#include "random.glsl"
#include "ray_common.glsl"

layout(binding = 0, set = 0, rgba32f) uniform image2D image;
layout(binding = 0, set = 1) uniform accelerationStructureEXT topLevelAS;
layout(binding = 0, set = 2) uniform CameraProperties {
    mat4 proj;
    mat4 view;
    mat4 inverse_view;
    mat4 inverse_proj;
} cam;
layout(location = 0) rayPayloadEXT RayPayload payload;

layout(push_constant) uniform Push {
    vec3 clear_color;
    uint frame_number;
} push;

vec3 randomHemisphereDirection(vec3 normal, vec2 random) {
    float phi = 2.0 * 3.14159265359 * random.x;
    float cosTheta = sqrt(1.0 - random.y);
    float sinTheta = sqrt(random.y);

    vec3 tangent = normalize(cross(abs(normal.y) < 0.999 ? vec3(0, 1, 0) : vec3(1, 0, 0), normal));
    vec3 bitangent = cross(normal, tangent);

    return normalize(
        tangent * (cos(phi) * sinTheta) +
            bitangent * (sin(phi) * sinTheta) +
            normal * cosTheta
    );
}

const int MAX_DEPTH = 1;

void main() {
    if (push.frame_number < 1000) {
        uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, push.frame_number);
        float r1 = rnd(seed);
        float r2 = rnd(seed);
        vec2 subpixel_jitter = push.frame_number == 0 ? vec2(0.5, 0.5) : vec2(r1, r2);

        const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + subpixel_jitter;
        const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
        vec2 d = inUV * 2.0 - 1.0;

        vec4 origin = cam.inverse_view * vec4(0, 0, 0, 1);
        vec4 target = cam.inverse_proj * vec4(d.xy, 1, 1);
        vec4 direction = cam.inverse_view * vec4(normalize(target.xyz), 0);

        vec3 rayOrigin = origin.xyz;
        vec3 rayDirection = direction.xyz;
        vec3 finalColor = vec3(0.0);
        vec3 throughput = vec3(1.0);

        for (int depth = 0; depth < MAX_DEPTH; depth++) {
            traceRayEXT(
                topLevelAS,
                gl_RayFlagsOpaqueEXT,
                0xFF,
                0,
                0,
                0,
                rayOrigin,
                0.001,
                rayDirection,
                10000.0,
                0
            );

            if (!payload.hit) {
                finalColor += throughput * push.clear_color;
                break;
            }

            throughput *= payload.color;
            Material mat = payload.material;
            finalColor += mat.emission_color * mat.emission_power;

            rayOrigin = payload.hitPosition;

            vec2 random = vec2(
                    rnd(seed),
                    rnd(seed)
                );

            rayDirection = randomHemisphereDirection(payload.hitNormal, random);
        }

        if (push.frame_number == 0) {
            imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(finalColor, 1.f));
        } else {
            float a = 1.0 / float(push.frame_number + 1);
            vec3 old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).rgb;
            imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color, finalColor, a), 1.f));
        }
    }
}
