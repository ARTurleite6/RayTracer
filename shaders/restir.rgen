#version 460

#extension GL_EXT_ray_tracing : require

#include "random.glsl"
#include "ray_common.glsl"

struct RestirPayload {
    vec3 position;
    vec3 normal;
    Material material;
    bool hit;
};

layout(location = 0) rayPayloadEXT RestirPayload payload;

layout(set = 0, binding = 0, rgba8) uniform image2D outputImage;

// (RGB) Material Albedo
layout(set = 0, binding = 1, rgba8) uniform image2D gBufferAlbedo;
// (RGB) Normal + (A) Roughness
layout(set = 0, binding = 2, rgba16f) uniform image2D gBufferNormal;
// (RGB) Position + (A) Metallic
layout(set = 0, binding = 3, rgba32f) uniform image2D gBufferPosition;
// (RGB) Emission Color + (A) Emission Power
layout(set = 0, binding = 4, rgba16f) uniform image2D gBufferEmission;
// (R) Transmission + (G) + (BA) Motion Vector
layout(set = 0, binding = 5, rgba16f) uniform image2D gBufferMaterialProperties;

layout(set = 1, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 2, binding = 0) uniform CameraProperties {
    mat4 proj;
    mat4 view;
    mat4 inverse_view;
    mat4 inverse_proj;
} cam;

layout(push_constant) uniform Push {
    vec3 clear_color;
    uint frame_number;
} push;

void main() {
    uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, push.frame_number);
    float r1 = rnd(seed);
    float r2 = rnd(seed);
    vec2 subpixel_jitter = vec2(0, 0); // push.frame_number == 0 ? vec2(0.5, 0.5) : vec2(r1, r2);

    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + subpixel_jitter;
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec4 origin = cam.inverse_view * vec4(0, 0, 0, 1);
    vec4 target = cam.inverse_proj * vec4(d.xy, 1, 1);
    vec4 direction = cam.inverse_view * vec4(normalize(target.xyz), 0);
    vec3 rayOrigin = origin.xyz;
    vec3 rayDirection = direction.xyz;

    payload.hit = false;

    traceRayEXT(
        topLevelAS,
        gl_RayFlagsOpaqueEXT,
        0xFF,
        0,
        0,
        0,
        rayOrigin,
        0.001,
        rayDirection,
        10000.0,
        0
    );
    const vec4 blackColor = vec4(0.0, 0.0, 0.0, 1.0);
    const ivec2 pixel = ivec2(gl_LaunchIDEXT.xy);
    if (payload.hit) {
        //populate gbuffers
        imageStore(gBufferAlbedo, pixel, vec4(payload.material.albedo, 1));
        imageStore(gBufferNormal, pixel, vec4(payload.normal, payload.material.roughness));
        imageStore(gBufferPosition, pixel, vec4(payload.position, payload.material.metallic));
        imageStore(gBufferEmission, pixel, vec4(payload.material.emission_color, payload.material.emission_power));
        // imageStore(gBufferEmission, pixel, vec4(payload.material.emission, payload.material.emission_power));

        imageStore(outputImage, pixel, vec4(payload.material.albedo, 1));
    } else {
        imageStore(gBufferAlbedo, pixel, blackColor);
        imageStore(gBufferNormal, pixel, blackColor);
        imageStore(gBufferPosition, pixel, blackColor);
        imageStore(gBufferEmission, pixel, blackColor);
        imageStore(outputImage, pixel, blackColor);
    }
}
